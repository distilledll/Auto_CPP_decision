# CPP Route Planner & Segment Map Generator

Проект превращает дорожную сеть OpenStreetMap в воспроизводимый эйлеров маршрут: анализирует баланс вершин, решает min-cost flow и добавляет минимальные искусственные ребра.
Результат — интерактивная HTML-карта и набор GPX/HTML сегментов для пошаговой навигации и экспорта.

---

# Содержание

1. [Краткое описание](#краткое-описание)
2. [Файлы проекта](#файлы-проекта)
3. [Требования и установка](#требования-и-установка)
4. [Быстрый запуск](#быстрый-запуск)
5. [Параметры и конфигурация](#параметры-и-конфигурация)
6. [Выходные файлы и структура папок](#выходные-файлы-и-структура-папок)
7. [Лицензия и контакты](#лицензия-и-контакты)

---

# Краткое описание

Проект превращает дорожную сеть OpenStreetMap в воспроизводимый эйлеров маршрут и генерирует удобные интерактивные карты + GPX для частей маршрута. Основная цель — минимальными вмешательствами (добавлением путей) получить маршрут, который проходит по всем рёбрам сети (или по выбранной подчасти) и легко экспортируется для инспекций/патрулей.

### Техническая часть (что делает система)

1. **Загрузка графа** — скачивает ориентированный граф дорог для указанного региона через osmnx и оставляет крупнейшую слабосвязную компоненту.
2. **Анализ баланса вершин** — вычисляет для каждой вершины разность out_degree - in_degree, выявляет узлы с избытком и дефицитом (т.е. где нужно добавить входы/выходы), готовит пары для коррекции.
3. **Вычисление стоимостей пар** — для каждой пары (избыток → дефицит) вычисляет кратчайшее расстояние: сначала в ориентированном графе (Dijkstra), при отсутствии пути — в неориентированном с добавочным штрафом.
4. **Решение задачи min-cost flow** — формирует вспомогательный направленный граф с демандами и пропускными способностями и решает минимально-стоимостный поток с помощью OR-Tools; результат — какие пары и в каком объёме „соединять“ можно минимальными затратами.
5. **Добавление искусственных ребер** — по найденным потокам добавляет в рабочую копию графа последовательности ребер (путей) — помеченные как artificial, иногда с флагом violates_direction (если использовался обратный/неориентированный обход).
6. **Проверка и получение Эйлерова цикла** — после добавлений пытается получить Eulerian circuit (через NetworkX) и извлекает порядок ребер.
7. **Восстановление геометрии** — для каждого ребра извлекает геометрию (если есть) или использует координаты узлов, формирует полный полилиний трека.
8. **Генерация карт и GPX** — сохраняет общую карту (folium) и разбивает маршрут на «большие» сегменты; для каждого сегмента создаёт интерактивную HTML-страницу с покадровой навигацией и файл GPX.

### Архитектура и ключевые компоненты

- **GeoUtils** — утилиты: haversine, densify (вставка промежуточных точек), подсчёт длины.
- **RoutePlanner** — основной класс: загрузка/обработка графа, построение вспомогательного графа, решение min-cost flow, конструкция рабочей граф-копии, получение эйлерова цикла и вывод полной геометрии.
- **SegmentMapGenerator** — отвечает за разбиение полного маршрута на сегменты, «уплотнение» точек, создание интерактивных HTML страниц и GPX.
- **OR-Tools wrapper** — адаптация входных данных NetworkX → SimpleMinCostFlow (шкала стоимостей, индексация вершин).
- **Визуализация** — folium + AntPath и вставленный JS для пошаговой навигации. ([Full_map](Карта_Китай-город.html), [Segments](Карты_Китай-город))

### Важные проектные решения / поведение

1. **Ориентированный приоритет + неориентированный fallback:** проект предпочитает ориентированные пути, но при отсутствии путей использует неориентированные с большим штрафом, чтобы не оставлять пары нерешёнными. Это сохраняет смысл направленных дорог, но делает алгоритм устойчивым.
2. **Искусственные ребра как метаданные:** добавленные пути помечаются, остаются в рабочем графе и визуально выделяются — это позволяет различать реальные и добавленные изменения.
3. **Кеширование маршрутов:** маршруты между узлами кешируются для повторного использования (экономия вызовов Dijkstra/OSM nearest).
4. **Масштабируемость:** Dijkstra для многих источников — ресурсозатратно; предусмотрены рекомендации по сужению зоны, фильтрам по типам дорог и возможной параллелизации.

---

# Файлы проекта

* `main_script.py` — основной файл (можно рассматривать как пример использования).
* `src/geoutils.py` — содержит класс `GeoUtils`.
* `src/routeplanner.py` — содержит класс `CPPRoutePlanner`.
* `src/segment_map_generator.py` — содержит класс `SegmentMapGenerator`.
* `requirements.txt` — список зависимостей.
* `Maps_<name>/` — папка с интерактивными HTML и GPX (генерируется при запуске).
* `Map_<name>.html` — итоговая карта полного маршрута (генерируется при запуске).

---

# Требования и установка

Рекомендуемая версия Python: **3.10+**.

1. Создайте виртуальное окружение и активируйте:

```bash
python -m venv .venv
source .venv/bin/activate
```

2. Установите зависимости (`requirements.txt`):

```bash
pip install -r requirements.txt
```

---

# Быстрый запуск

1. Подготовьте окружение и зависимости (см. предыдущий раздел).
2. Измените настройки в файле `main_script.py` при необходимости:
   * `district_name` — название региона/района для загрузки из OSM (строка, понятная geocoding).
   * `custom_filter` — фильтр OSM для выбора типов дорог.
   * Параметры для `SegmentMapGenerator.generate_segment_maps`: `max_km`, `step_m`, `densify_m`.
4. Запустите:

```bash
python3 main_script.py
```

---

# Параметры и конфигурация

В коде используется несколько ключевых настроек. Кратко:

* `district_name` — строка для `osmnx.graph_from_place(...)`. Например: `"Китай-город, Москва, Россия"`.
* `custom_filter` — строка фильтра по тегам OSM (по умолчанию выбираются основные типы дорог).
* `address` — адрес первого узла в графе, если None то берется середина "местности".
* `undirected_penalty` (в `RoutePlanner`) — штраф в метрах, добавляемый при использовании неориентированного обхода вместо ориентированного пути (по умолчанию большой — чтобы предпочитать ориентированные маршруты).
* `max_km` (в `SegmentMapGenerator.generate_segment_maps`) — максимальная длина «большого сегмента» в километрах при разбиении.
* `step_m` — размер шагов (в метрах) внутри сегмента для пошаговой навигации (по умолчанию 400–500 м).
* `densify_m` — опция для вставки промежуточных точек, чтобы расстояние между последовательными точками было не больше указанного (обычно 20–50 м).

---

# Выходные файлы и структура папок

После успешного выполнения вы получите:

* `Map_<region>.html` — единая HTML-карта с полным маршрутом и пометкой добавленных искусственных ребер.
* Папка `Maps_<region>/` с файлами `seg_<n>.html` и `seg_<n>.gpx`.

---

# Дальнейшие улучшения (идеи)

* Логирование (`logging`) вместо `print` для гибкой настройки уровней логов.
* Новые параметры для сегментации пути.
* Оптимизация алгоритма построения CPP.

---

# Лицензия и контакты

Этот проект был реализован в качестве рабочей утилиты за неимением необходимых мне функций и реализаций алгоритма CPP. 
Сотрудничество и предложения: tg - `@distilledll`.

